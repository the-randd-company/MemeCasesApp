{"file_contents":{"src/Scenes/CaseOpening/ScrollFrame.js":{"content":"import React, { useRef, useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity, ScrollView, Dimensions, Animated, Image } from 'react-native';\nimport CaseDrop from './CaseDrop';\nimport drops from '../../configs/DropsConfig';\nimport { addToInventory, removeFromInventory, getUpgrades } from '../../DataStorage';\n\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\nconst ITEM_WIDTH = 136; // 120px + 16px gap\n\nconst ScrollFrame = ({ money, updateMoney, onFinish, onInventory, onSell, onShowResultChange, caseSpeed = 10, caseData = null }) => {\n  const scrollRef = useRef(null);\n  const [isSpinning, setIsSpinning] = useState(false);\n  const [wonItem, setWonItem] = useState(null);\n  const [showResult, setShowResult] = useState(false);\n  const [rebirthMultiplier, setRebirthMultiplier] = useState(1);\n  const [imagesPreloaded, setImagesPreloaded] = useState(false);\n\n  // Use case data drops if provided, otherwise use default drops\n  const baseItems = caseData && caseData.dropWeights ? \n    Object.keys(caseData.dropWeights).map(name => drops.find(drop => drop.name === name)).filter(Boolean) :\n    drops;\n  \n  // Store items in state to ensure consistency between render and spin\n  const [items, setItems] = useState([]);\n\n  // Preload all images on component mount\n  useEffect(() => {\n    preloadImages();\n  }, []);\n\n  // Generate items once when component mounts or caseData changes\n  useEffect(() => {\n    const generatedItems = generateWeightedItems(300, caseData?.dropWeights);\n    setItems(generatedItems);\n  }, [caseData]);\n\n  // Load rebirth multiplier on mount\n  useEffect(() => {\n    loadRebirthMultiplier();\n  }, []);\n\n  const preloadImages = async () => {\n    try {\n      const preloadPromises = drops.map(drop => {\n        if (typeof drop.imageSrc === 'number') {\n          // For local assets, we can preload by creating temporary Image components\n          return new Promise((resolve, reject) => {\n            Image.prefetch(Image.resolveAssetSource(drop.imageSrc).uri)\n              .then(resolve)\n              .catch(resolve); // Even if prefetch fails, continue\n          });\n        }\n        return Promise.resolve();\n      });\n\n      await Promise.all(preloadPromises);\n      setImagesPreloaded(true);\n    } catch (error) {\n      console.log('Image preloading completed with some errors');\n      setImagesPreloaded(true); // Continue anyway\n    }\n  };\n\n  const loadRebirthMultiplier = async () => {\n    const upgrades = await getUpgrades();\n    setRebirthMultiplier(upgrades.rebirthMultiplier || 1);\n  };\n\n  // Notify parent when showResult changes\n  React.useEffect(() => {\n    if (typeof onShowResultChange === 'function') {\n      onShowResultChange(showResult);\n    }\n  }, [showResult, onShowResultChange]);\n\n  // Function to generate weighted random items for display\n  const generateWeightedItems = (count, weights) => {\n    if (!weights) return [...Array(count)].map(() => drops[Math.floor(Math.random() * drops.length)]);\n    \n    const weightedItems = [];\n    const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);\n    \n    for (let i = 0; i < count; i++) {\n      let random = Math.random() * totalWeight;\n      let selectedItem = null;\n      \n      for (const itemName in weights) {\n        random -= weights[itemName];\n        if (random <= 0) {\n          selectedItem = drops.find(drop => drop.name === itemName);\n          break;\n        }\n      }\n      \n      // Fallback if no item selected\n      if (!selectedItem) {\n        selectedItem = drops[Math.floor(Math.random() * drops.length)];\n      }\n      \n      weightedItems.push(selectedItem);\n    }\n    \n    return weightedItems;\n  };\n  \n  const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);\n\n  const handleSpin = async () => {\n    if (isSpinning || !scrollRef.current || !imagesPreloaded || items.length === 0) return;\n    setIsSpinning(true);\n    setShowResult(false);\n    setWonItem(null);\n    \n    // Reset scroll position\n    scrollRef.current.scrollTo({ x: 0, animated: false });\n  \n    // Use the EXISTING items array that's already rendered\n    // Select winning item FROM THE ACTUAL ITEMS ARRAY\n    let winningIndex;\n    if (caseData && caseData.dropWeights) {\n      // Use weighted selection from the actual items array\n      const weights = caseData.dropWeights;\n      const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);\n      let random = Math.random() * totalWeight;\n      \n      let selectedItemName = null;\n      for (const itemName in weights) {\n        random -= weights[itemName];\n        if (random <= 0) {\n          selectedItemName = itemName;\n          break;\n        }\n      }\n      \n      // Fallback if no item selected\n      if (!selectedItemName) {\n        selectedItemName = baseItems[Math.floor(Math.random() * baseItems.length)].name;\n      }\n      \n      // Find ALL occurrences of the selected item in the actual items array\n      const allOccurrences = items\n        .map((item, index) => item.name === selectedItemName ? index : -1)\n        .filter(index => index !== -1);\n      \n      // Pick a random occurrence that's far enough in the list for dramatic effect\n      const minStartIndex = Math.floor(items.length * 0.6);\n      const validOccurrences = allOccurrences.filter(index => index >= minStartIndex);\n      \n      if (validOccurrences.length > 0) {\n        winningIndex = validOccurrences[Math.floor(Math.random() * validOccurrences.length)];\n      } else {\n        winningIndex = allOccurrences.length > 0 \n          ? allOccurrences[allOccurrences.length - 1] \n          : Math.floor(items.length * 0.8);\n      }\n    } else {\n      // Fallback: random selection from items array\n      winningIndex = Math.floor(Math.random() * items.length);\n    }\n  \n    const centerOffset = (SCREEN_WIDTH - 32) / 2 - ITEM_WIDTH / 2;\n    const targetScroll = (winningIndex * ITEM_WIDTH) - centerOffset;\n  \n    const duration = caseSpeed * 1000;\n    const startTime = Date.now();\n    \n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      const easedProgress = easeOutQuart(progress);\n  \n      scrollRef.current?.scrollTo({ \n        x: targetScroll * easedProgress, \n        animated: false\n      });\n      \n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      } else {\n        // Ensure final scroll position is exact\n        scrollRef.current?.scrollTo({ \n          x: targetScroll, \n          animated: false\n        });\n        \n        setIsSpinning(false);\n        const item = items[winningIndex]; // Use item from the actual items array\n        const acquiredAt = Date.now();\n        const fullItem = { ...item, acquiredAt };\n        setWonItem(fullItem);\n        // Add to inventory immediately on roll finish\n        addToInventory(fullItem);\n        setTimeout(() => { setShowResult(true); }, 500);\n      }\n    };\n    requestAnimationFrame(animate);\n  };\n\n  const handleInventory = async () => {\n    if (!wonItem) return;\n    // Item is already in inventory, just trigger navigation\n    if (onInventory) onInventory();\n    if (onFinish) onFinish();\n  };\n\n  const handleSell = async () => {\n    if (!wonItem) return;\n    // Remove from inventory when selling\n    await removeFromInventory({ id: wonItem.id, acquiredAt: wonItem.acquiredAt });\n    // Grant value to user with rebirth multiplier\n    const sellValue = Math.floor((wonItem.value || 0) * rebirthMultiplier);\n    await updateMoney(money + sellValue);\n    if (onSell) onSell(wonItem);\n    if (onFinish) onFinish();\n  };\n\n  // Calculate sell value with multiplier for display\n  const sellValue = wonItem ? Math.floor((wonItem.value || 0) * rebirthMultiplier) : 0;\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.card}>\n        <Text style={[styles.title, wonItem && { color: wonItem?.rarityColor }]}>\n          {wonItem ? wonItem.name : 'Case Opening'}\n        </Text>\n        {showResult ? (\n          <>\n            <View style={styles.resultContainer}>\n              <CaseDrop dropImage={wonItem} />\n            </View>\n            <View style={styles.resultActions}>\n              <TouchableOpacity style={[styles.button]} onPress={handleInventory}>\n                <Text style={styles.buttonText}>View in Inventory</Text>\n              </TouchableOpacity>\n              <TouchableOpacity style={[styles.button, { backgroundColor: '#10b981' }]} onPress={handleSell}>\n                <Text style={styles.buttonText}>\n                  Sell Item (${sellValue})\n                  {rebirthMultiplier > 1 && (\n                    <Text style={styles.multiplierText}> {rebirthMultiplier.toFixed(2)}x</Text>\n                  )}\n                </Text>\n              </TouchableOpacity>\n            </View>\n          </>\n        ) : (\n          <View style={styles.scrollContainer}>\n            <View style={styles.indicatorLine} />\n            <ScrollView\n              ref={scrollRef}\n              horizontal\n              showsHorizontalScrollIndicator={false}\n              scrollEnabled={false}\n              contentContainerStyle={styles.scrollContent}\n            >\n              {items.map((item, index) => (\n                <View key={index} style={styles.itemWrapper}>\n                  <CaseDrop dropImage={item} />\n                </View>\n              ))}\n            </ScrollView>\n          </View>\n        )}\n        {!showResult && (\n          <TouchableOpacity\n            onPress={handleSpin}\n            disabled={isSpinning || !imagesPreloaded || items.length === 0}\n            style={[styles.button, (isSpinning || !imagesPreloaded || items.length === 0) && styles.buttonDisabled]}\n            activeOpacity={0.8}\n          >\n            <Text style={styles.buttonText}>\n              {!imagesPreloaded ? 'Loading...' : isSpinning ? 'Opening...' : 'Open Case'}\n            </Text>\n          </TouchableOpacity>\n        )}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n    justifyContent: 'center',\n    padding: 16,\n  },\n  card: {\n    backgroundColor: '#2a2a2a',\n    borderRadius: 12,\n    padding: 16,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.3,\n    shadowRadius: 8,\n    elevation: 8,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    textAlign: 'center',\n    marginBottom: 16,\n  },\n  scrollContainer: {\n    position: 'relative',\n    marginBottom: 16,\n    height: 152, // Fixed height to prevent layout shift\n  },\n  indicatorLine: {\n    position: 'absolute',\n    left: '50%',\n    marginLeft: -2,\n    top: 0,\n    bottom: 0,\n    width: 4,\n    backgroundColor: '#fbbf24',\n    zIndex: 10,\n    shadowColor: '#fbbf24',\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.8,\n    shadowRadius: 8,\n    elevation: 10,\n  },\n  scrollContent: {\n    paddingVertical: 16,\n    paddingHorizontal: 8,\n  },\n  itemWrapper: {\n    marginRight: 16,\n  },\n  resultContainer: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginBottom: 16,\n    height: 152, // Same height as scroll container\n  },\n  resultActions: {\n    marginTop: 24,\n    gap: 16,\n  },\n  button: {\n    backgroundColor: '#f59e0b',\n    paddingVertical: 16,\n    paddingHorizontal: 24,\n    borderRadius: 8,\n    shadowColor: '#f59e0b',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.3,\n    shadowRadius: 8,\n    elevation: 6,\n  },\n  buttonDisabled: {\n    backgroundColor: '#6b7280',\n    shadowColor: '#6b7280',\n  },\n  buttonText: {\n    color: '#ffffff',\n    fontSize: 18,\n    fontWeight: 'bold',\n    textAlign: 'center',\n  },\n  multiplierText: {\n    fontSize: 14,\n    color: '#fbbf24',\n    fontWeight: '600',\n  },\n});\n\nexport default ScrollFrame;","size_bytes":11826},"src/ClickerButton.js":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity, Animated } from 'react-native';\n\nconst ClickerButton = ({ \n  onPress, \n  earnAmount = 1, \n  clickerPower = 1, \n  rebirthMultiplier = 1,\n  autoClickPower = 0\n}) => {\n  const [plusOneEffects, setPlusOneEffects] = useState([]);\n  const buttonScale = useRef(new Animated.Value(1)).current;\n  const lastPressTime = useRef(0);\n  const effectCount = useRef(0);\n  const MAX_EFFECTS = 8;\n\n  // Calculate total click value with rebirth multiplier\n  const totalClickValue = Math.floor(clickerPower * rebirthMultiplier);\n\n  // Auto clicker functionality - Fixed interval with multiplied earnings\n  useEffect(() => {\n    if (autoClickPower <= 0) return;\n\n    const autoClickInterval = setInterval(() => {\n      handleAutoClick();\n    }, 5000); // Fixed 5 second interval\n\n    return () => clearInterval(autoClickInterval);\n  }, [autoClickPower, clickerPower, rebirthMultiplier, onPress]);\n\n  const animatePlusOne = (isAutoClick = false, multiplier = 1) => {\n    if (effectCount.current >= MAX_EFFECTS) {\n      return;\n    }\n\n    const id = Date.now() + Math.random();\n    effectCount.current++;\n\n    const screenWidth = 350;\n    const buttonHeight = 50;\n    \n    const randomX = Math.random() * (screenWidth - 30);\n    const randomY = Math.random() * (buttonHeight - 20);\n    \n    const newEffect = {\n      id,\n      x: randomX,\n      y: randomY,\n      opacity: new Animated.Value(0),\n      translateY: new Animated.Value(0),\n      isAutoClick,\n      multiplier,\n    };\n\n    setPlusOneEffects(prev => [...prev.slice(-MAX_EFFECTS + 1), newEffect]);\n\n    Animated.parallel([\n      Animated.timing(newEffect.opacity, {\n        toValue: 1,\n        duration: 100,\n        useNativeDriver: true,\n      }),\n      Animated.timing(newEffect.translateY, {\n        toValue: -40,\n        duration: 600,\n        useNativeDriver: true,\n      }),\n    ]).start(() => {\n      Animated.timing(newEffect.opacity, {\n        toValue: 0,\n        duration: 200,\n        useNativeDriver: true,\n      }).start(() => {\n        setPlusOneEffects(prev => prev.filter(effect => effect.id !== id));\n        effectCount.current--;\n      });\n    });\n  };\n\n  const handleAutoClick = () => {\n    if (autoClickPower <= 0) return;\n\n    // Calculate total auto-click earnings (base click value multiplied by auto-click power)\n    const autoClickMultiplier = autoClickPower;\n    const totalAutoEarnings = totalClickValue * autoClickMultiplier;\n\n    // Show appropriate animation\n    if (autoClickMultiplier > 1) {\n      // Show multiplier effect for high-value auto clicks\n      animatePlusOne(true, autoClickMultiplier);\n    } else {\n      // Show normal effect for single clicks\n      if (Math.random() > 0.7 || plusOneEffects.length < 2) {\n        animatePlusOne(true, 1);\n      }\n    }\n\n    // Trigger the click multiple times based on auto-click power\n    // This ensures the money is added correctly through the existing onPress mechanism\n    for (let i = 0; i < autoClickMultiplier; i++) {\n      onPress();\n    }\n  };\n\n  const handlePress = () => {\n    const now = Date.now();\n    \n    // Throttle rapid clicks to prevent animation overload\n    if (now - lastPressTime.current < 50) {\n      onPress();\n      return;\n    }\n    lastPressTime.current = now;\n\n    // Quick scale animation\n    buttonScale.setValue(0.92);\n    Animated.spring(buttonScale, {\n      toValue: 1,\n      tension: 200,\n      friction: 3,\n      useNativeDriver: true,\n    }).start();\n\n    // Only show +1 effect occasionally during rapid clicking\n    if (Math.random() > 0.3 || plusOneEffects.length < 3) {\n      animatePlusOne(false, 1);\n    }\n\n    onPress();\n  };\n\n  // Clean up effects on unmount\n  React.useEffect(() => {\n    return () => {\n      setPlusOneEffects([]);\n      effectCount.current = 0;\n    };\n  }, []);\n\n  return (\n    <View style={styles.clickerWrapper}>\n      {/* Render all +1 effects */}\n      {plusOneEffects.map((effect) => (\n        <Animated.Text\n          key={effect.id}\n          style={[\n            styles.plusOne,\n            effect.isAutoClick && styles.autoClickPlusOne,\n            effect.multiplier > 1 && styles.multiplierPlusOne,\n            {\n              position: 'absolute',\n              left: effect.x,\n              top: effect.y,\n              opacity: effect.opacity,\n              transform: [\n                { translateY: effect.translateY },\n              ],\n            },\n          ]}>\n          {effect.multiplier > 1 ? `+${totalClickValue * effect.multiplier}` : `+${totalClickValue}`}\n          {effect.multiplier > 1 && <Text style={styles.multiplierIndicator}> ({effect.multiplier}x)</Text>}\n        </Animated.Text>\n      ))}\n      \n      <TouchableOpacity\n        style={styles.clickerButton}\n        onPress={handlePress}\n        activeOpacity={0.7}\n        delayPressIn={0}\n        delayPressOut={0}\n      >\n        <Animated.View\n          style={[\n            styles.clickerButtonInner,\n            {\n              transform: [{ scale: buttonScale }],\n            },\n          ]}\n        >\n          <Text style={styles.clickerLabel}>\n            üí∏ Tap for +${totalClickValue}!\n            {rebirthMultiplier > 1 && (\n              <Text style={styles.multiplierText}> ({rebirthMultiplier.toFixed(2)}x)</Text>\n            )}\n          </Text>\n          {autoClickPower > 0 && (\n            <Text style={styles.autoClickInfo}>\n              Auto: +${totalClickValue * autoClickPower} every 5s\n            </Text>\n          )}\n        </Animated.View>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  clickerWrapper: {\n    flexDirection: 'row',\n    alignItems: 'stretch',\n    marginBottom: 0,\n    marginTop: 0,\n    width: '100%',\n    minHeight: 50,\n  },\n  clickerButton: {\n    flex: 1,\n    width: '100%',\n    backgroundColor: '#10b981',\n    borderRadius: 0,\n    shadowColor: '#10b981',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.18,\n    shadowRadius: 6,\n    elevation: 4,\n    margin: 0,\n  },\n  clickerButtonInner: {\n    paddingVertical: 10,\n    alignItems: 'center',\n    justifyContent: 'center',\n    width: '100%',\n    minHeight: 50,\n  },\n  clickerLabel: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#fff',\n    textAlign: 'center',\n  },\n  autoClickInfo: {\n    fontSize: 14,\n    color: '#fbbf24',\n    fontWeight: '600',\n    textAlign: 'center',\n    marginTop: 4,\n  },\n  multiplierText: {\n    fontSize: 16,\n    color: '#fbbf24',\n    fontWeight: '600',\n  },\n  plusOne: {\n    fontSize: 24,\n    color: '#10b981',\n    fontWeight: 'bold',\n    textShadowColor: '#000',\n    textShadowRadius: 4,\n    textShadowOffset: { width: 0, height: 2 },\n    elevation: 5,\n    zIndex: 1000,\n  },\n  autoClickPlusOne: {\n    color: '#60a5fa', // Blue for auto clicks\n  },\n  multiplierPlusOne: {\n    fontSize: 20,\n    color: '#fbbf24', // Gold for multiplier clicks\n  },\n  multiplierIndicator: {\n    fontSize: 16,\n    color: '#fbbf24',\n  },\n});\n\nexport default ClickerButton;","size_bytes":7021},"index.js":{"content":"import { registerRootComponent } from 'expo';\n\nimport App from './App';\n\n// registerRootComponent calls AppRegistry.registerComponent('main', () => App);\n// It also ensures that whether you load the app in Expo Go or in a native build,\n// the environment is set up appropriately\nregisterRootComponent(App);\n","size_bytes":307},"src/Scenes/Rebirthing/Rebirth.js":{"content":"// RebirthScene.js\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity, Alert, ScrollView } from 'react-native';\nimport { getInventory, setInventory, getUpgrades, setUpgrades } from '../../DataStorage';\nimport {\n  REBIRTH_REQUIREMENT,\n  calculateWipedValue,\n  calculateMultiplierGain,\n  getNextMilestone,\n  canRebirth,\n  performRebirth,\n} from './RebirthCalculator';\n\nconst RebirthScene = ({ money, updateMoney, onUpgradePurchased }) => {\n  const [inventory, setInventoryState] = useState([]);\n  const [rebirthMultiplier, setRebirthMultiplier] = useState(1);\n  const [totalRebirths, setTotalRebirths] = useState(0);\n  const [showInfo, setShowInfo] = useState(false);\n\n  useEffect(() => {\n    loadInventory();\n    loadRebirthData();\n  }, []);\n\n  const loadInventory = async () => {\n    const savedInventory = await getInventory();\n    setInventoryState(savedInventory || []);\n  };\n\n  const loadRebirthData = async () => {\n    const upgrades = await getUpgrades();\n    setRebirthMultiplier(upgrades.rebirthMultiplier || 1);\n    setTotalRebirths(upgrades.totalRebirths || 0);\n  };\n\n  const handleRebirth = async () => {\n    const wipedValue = calculateWipedValue(inventory);\n\n    if (!canRebirth(wipedValue)) {\n      Alert.alert(\n        'Not Enough Value',\n        `You need $${REBIRTH_REQUIREMENT.toLocaleString()} in wipeable inventory value to rebirth.`,\n        [{ text: 'OK' }]\n      );\n      return;\n    }\n\n    const multiplierGain = calculateMultiplierGain(wipedValue);\n    const newTotalMultiplier = (rebirthMultiplier + (multiplierGain - 1)).toFixed(2);\n\n    Alert.alert(\n      'Confirm Rebirth',\n      `This will:\\n‚Ä¢ Wipe all common, rare, legendary, and mythic items\\n‚Ä¢ Reset ALL upgrades (case speed, clicker power)\\n‚Ä¢ Grant permanent ${multiplierGain.toFixed(2)}x click multiplier\\n\\nYour seasonal/vaulted items will be preserved.`,\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Rebirth',\n          style: 'destructive',\n          onPress: async () => {\n            // Perform rebirth - only keep protected items\n            const protectedItems = performRebirth(inventory);\n            const newTotalRebirths = totalRebirths + 1;\n\n            // Update inventory\n            await setInventory(protectedItems);\n            setInventoryState(protectedItems);\n\n            // Get current upgrades\n            const upgrades = await getUpgrades();\n            \n            // Reset all upgrades to level 0, but preserve rebirth progress\n            const updatedUpgrades = {\n              // Reset gameplay upgrades to 0\n              caseSpeed: 0,\n              clickerPower: 0,\n              // Preserve and update rebirth progress\n              rebirthMultiplier: (upgrades.rebirthMultiplier || 1) + (multiplierGain - 1),\n              totalRebirths: newTotalRebirths,\n            };\n\n            await setUpgrades(updatedUpgrades);\n            \n            // Update local state\n            setRebirthMultiplier(updatedUpgrades.rebirthMultiplier);\n            setTotalRebirths(newTotalRebirths);\n\n            // Notify parent component to refresh upgrade states\n            if (onUpgradePurchased) {\n              onUpgradePurchased();\n            }\n\n            Alert.alert(\n              'Rebirth Complete!',\n              `All upgrades have been reset to level 0!\\nYour click power has been multiplied by ${multiplierGain.toFixed(2)}x!\\nTotal multiplier: ${newTotalMultiplier}x`,\n              [{ text: 'Awesome!' }]\n            );\n          },\n        },\n      ]\n    );\n  };\n\n  const wipedValue = calculateWipedValue(inventory);\n  const rebirthAvailable = canRebirth(wipedValue);\n  const multiplierGain = calculateMultiplierGain(wipedValue);\n  const nextMilestone = getNextMilestone(wipedValue);\n\n  return (\n    <View style={styles.container}>\n      {/* Header */}\n      <View style={styles.header}>\n        <Text style={styles.headerTitle}>Rebirth</Text>\n        <View style={styles.statsRow}>\n          <View style={styles.stat}>\n            <Text style={styles.statLabel}>Multiplier</Text>\n            <Text style={styles.statValue}>{rebirthMultiplier.toFixed(2)}x</Text>\n          </View>\n          <View style={styles.stat}>\n            <Text style={styles.statLabel}>Rebirths</Text>\n            <Text style={styles.statValue}>{totalRebirths}</Text>\n          </View>\n        </View>\n      </View>\n\n      {/* Scrollable Content */}\n      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>\n        {/* Net Worth Display */}\n        <View style={styles.netWorthContainer}>\n          <Text style={styles.netWorthLabel}>Net Worth</Text>\n          <Text style={styles.netWorthValue}>\n            ${wipedValue.toLocaleString()}\n            <Text style={styles.netWorthRequirement}> / ${REBIRTH_REQUIREMENT.toLocaleString()}</Text>\n          </Text>\n          <View style={styles.progressBar}>\n            <View \n              style={[\n                styles.progressFill,\n                { width: `${Math.min(100, (wipedValue / REBIRTH_REQUIREMENT) * 100)}%` }\n              ]} \n            />\n          </View>\n          \n          {/* Multiplier Gain Display */}\n          {rebirthAvailable && (\n            <View style={styles.multiplierDisplay}>\n              <Text style={styles.multiplierLabel}>Multiplier Gain</Text>\n              <Text style={styles.multiplierValue}>+{multiplierGain.toFixed(2)}x</Text>\n              {nextMilestone && (\n                <Text style={styles.nextMilestone}>\n                  Next: {nextMilestone.multiplier.toFixed(1)}x at ${nextMilestone.value.toLocaleString()}\n                </Text>\n              )}\n            </View>\n          )}\n        </View>\n\n        {/* Rebirth Button */}\n        <TouchableOpacity\n          style={[\n            styles.rebirthButton,\n            rebirthAvailable ? styles.rebirthButtonActive : styles.rebirthButtonDisabled,\n          ]}\n          onPress={handleRebirth}\n          disabled={!rebirthAvailable}\n          activeOpacity={0.7}\n        >\n          {rebirthAvailable ? (\n            <>\n              <Text style={styles.rebirthButtonIcon}>üî•</Text>\n              <Text style={styles.rebirthButtonText}>REBIRTH</Text>\n              <Text style={styles.rebirthButtonSubtext}>\n                Gain {multiplierGain.toFixed(2)}x Multiplier\n              </Text>\n              <Text style={styles.rebirthButtonSubtext}>\n                Total: {(rebirthMultiplier + (multiplierGain - 1)).toFixed(2)}x\n              </Text>\n            </>\n          ) : (\n            <>\n              <Text style={styles.rebirthButtonText}>REQUIREMENT NOT MET</Text>\n              <Text style={styles.rebirthButtonSubtext}>\n                Need ${(REBIRTH_REQUIREMENT - wipedValue).toLocaleString()} more\n              </Text>\n            </>\n          )}\n        </TouchableOpacity>\n\n        {/* Rebirth Info Dropdown */}\n        <TouchableOpacity \n          style={styles.infoHeader}\n          onPress={() => setShowInfo(!showInfo)}\n          activeOpacity={0.7}\n        >\n          <Text style={styles.infoHeaderText}>Rebirth Info</Text>\n          <Text style={styles.infoHeaderIcon}>{showInfo ? '‚ñ≤' : '‚ñº'}</Text>\n        </TouchableOpacity>\n\n        {showInfo && (\n          <View style={styles.infoContent}>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>üí•</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Wipe:</Text> Common, Rare, Legendary, Mythic items\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>üõ°Ô∏è</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Keep:</Text> Seasonal, Vaulted, Special items\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>üîÑ</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Reset:</Text> All upgrades (case speed, clicker power)\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>‚ö°</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Multiplier:</Text> Based on net worth with diminishing returns\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>üí∞</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Base Requirement:</Text> ${REBIRTH_REQUIREMENT.toLocaleString()} for 1.2x\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>üìà</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Scaling:</Text> Each doubling adds +0.1x multiplier\n              </Text>\n            </View>\n            <View style={styles.infoItem}>\n              <Text style={styles.infoIcon}>‚ú®</Text>\n              <Text style={styles.infoText}>\n                <Text style={styles.infoHighlight}>Stacking:</Text> All multipliers multiply together\n              </Text>\n            </View>\n          </View>\n        )}\n\n        {/* Spacer to ensure content is scrollable */}\n        <View style={styles.bottomSpacer} />\n      </ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n  },\n  header: {\n    paddingHorizontal: 20,\n    paddingVertical: 16,\n    backgroundColor: '#2a2a2a',\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 12,\n    textAlign: 'center',\n  },\n  statsRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n  },\n  stat: {\n    alignItems: 'center',\n  },\n  statLabel: {\n    fontSize: 12,\n    color: '#888',\n    marginBottom: 4,\n  },\n  statValue: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    padding: 20,\n  },\n  netWorthContainer: {\n    backgroundColor: '#2a2a2a',\n    borderRadius: 12,\n    padding: 20,\n    alignItems: 'center',\n    marginBottom: 20,\n  },\n  netWorthLabel: {\n    fontSize: 16,\n    color: '#888',\n    marginBottom: 8,\n  },\n  netWorthValue: {\n    fontSize: 28,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 12,\n  },\n  netWorthRequirement: {\n    fontSize: 16,\n    color: '#888',\n  },\n  progressBar: {\n    width: '100%',\n    height: 8,\n    backgroundColor: '#3a3a3a',\n    borderRadius: 4,\n    overflow: 'hidden',\n    marginBottom: 12,\n  },\n  progressFill: {\n    height: '100%',\n    backgroundColor: '#f59e0b',\n    borderRadius: 4,\n  },\n  multiplierDisplay: {\n    alignItems: 'center',\n    marginTop: 8,\n  },\n  multiplierLabel: {\n    fontSize: 14,\n    color: '#888',\n    marginBottom: 4,\n  },\n  multiplierValue: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#10b981',\n    marginBottom: 4,\n  },\n  nextMilestone: {\n    fontSize: 12,\n    color: '#ccc',\n    fontStyle: 'italic',\n  },\n  rebirthButton: {\n    backgroundColor: '#374151',\n    borderRadius: 12,\n    padding: 20,\n    alignItems: 'center',\n    marginBottom: 16,\n    minHeight: 120,\n    justifyContent: 'center',\n  },\n  rebirthButtonActive: {\n    backgroundColor: '#7c2d12',\n  },\n  rebirthButtonDisabled: {\n    backgroundColor: '#374151',\n  },\n  rebirthButtonIcon: {\n    fontSize: 32,\n    marginBottom: 8,\n  },\n  rebirthButtonText: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 4,\n    textAlign: 'center',\n  },\n  rebirthButtonSubtext: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n  },\n  infoHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    backgroundColor: '#2a2a2a',\n    padding: 16,\n    borderRadius: 8,\n  },\n  infoHeaderText: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#ffffff',\n  },\n  infoHeaderIcon: {\n    fontSize: 14,\n    color: '#888',\n  },\n  infoContent: {\n    backgroundColor: '#2a2a2a',\n    borderBottomLeftRadius: 8,\n    borderBottomRightRadius: 8,\n    padding: 16,\n    marginTop: 1,\n  },\n  infoItem: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    marginBottom: 12,\n  },\n  infoIcon: {\n    fontSize: 16,\n    marginRight: 12,\n    width: 20,\n    textAlign: 'center',\n  },\n  infoText: {\n    flex: 1,\n    fontSize: 14,\n    color: '#ccc',\n    lineHeight: 20,\n  },\n  infoHighlight: {\n    color: '#f59e0b',\n    fontWeight: '600',\n  },\n  bottomSpacer: {\n    height: 40,\n  },\n});\n\nexport default RebirthScene;","size_bytes":12826},"src/Scenes/Upgrades.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';\nimport { getMoney, setMoney as setMoneyStorage, getUpgrades, setUpgrades } from '../DataStorage';\n\nconst UpgradesScene = ({ money, updateMoney, onUpgradePurchased }) => {\n  const [upgrades, setUpgradesState] = useState({\n    caseSpeed: 0,\n    clickerPower: 0,\n    autoClickPower: 0,\n  });\n\n  // Load upgrades on component mount\n  useEffect(() => {\n    loadUpgrades();\n  }, []);\n\n  const loadUpgrades = async () => {\n    const savedUpgrades = await getUpgrades();\n    setUpgradesState(savedUpgrades);\n  };\n\n  const saveUpgrades = async (newUpgrades) => {\n    setUpgradesState(newUpgrades);\n    await setUpgrades(newUpgrades);\n  };\n\n  const handleUpgrade = async (upgradeType, cost, currentLevel) => {\n    if (money < cost) return;\n\n    const newMoney = money - cost;\n    const newUpgrades = {\n      ...upgrades,\n      [upgradeType]: currentLevel + 1,\n    };\n\n    await setMoneyStorage(newMoney);\n    updateMoney(newMoney);\n    await saveUpgrades(newUpgrades);\n    \n    // Notify parent component to refresh upgrade states\n    if (onUpgradePurchased) {\n      onUpgradePurchased();\n    }\n  };\n\n  const getCaseSpeedDuration = () => {\n    const baseDuration = 10; // seconds\n    const reduction = upgrades.caseSpeed * 0.1;\n    return Math.max(3.5, baseDuration - reduction); // Minimum 3.5 seconds\n  };\n\n  const getClickerPower = () => {\n    return 1 + upgrades.clickerPower; // Base 1 + upgrades\n  };\n  \n  const getAutoClickPower = () => {\n    return upgrades.autoClickPower;\n  }\n\n  const upgradesData = [\n    {\n      id: 'caseSpeed',\n      name: 'Case Opening Speed',\n      description: `Reduces case opening time by 0.1s (Current: ${getCaseSpeedDuration().toFixed(1)}s)`,\n      baseCost: 50,\n      costMultiplier: 1.5,\n      currentLevel: upgrades.caseSpeed,\n      maxLevel: 65, // Max 6.5 seconds reduction (0.1 * 65 = 6.5s, so 10 - 6.5 = 3.5s minimum)\n    },\n    {\n      id: 'clickerPower',\n      name: 'Clicker Power',\n      description: `Increases money per click by +1 (Current: +${getClickerPower()})`,\n      baseCost: 100,\n      costMultiplier: 1.25,\n      currentLevel: upgrades.clickerPower,\n      maxLevel: Infinity, // No maximum limit\n    },\n    {\n        id: 'autoClickPower',\n        name: 'Auto Clicker',\n        description: `Multiplies auto-click earnings (Current: ${getAutoClickPower()}x every 5 seconds)`,\n        baseCost: 250,\n        costMultiplier: 1.5,\n        currentLevel: upgrades.autoClickPower,\n        maxLevel: 20,\n    },\n  ];\n\n  const getUpgradeCost = (upgrade) => {\n    return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, upgrade.currentLevel));\n  };\n\n  const UpgradeCard = ({ upgrade }) => {\n    const cost = getUpgradeCost(upgrade);\n    const canAfford = money >= cost;\n    const isMaxLevel = upgrade.maxLevel !== Infinity && upgrade.currentLevel >= upgrade.maxLevel;\n\n    return (\n      <View style={styles.upgradeCard}>\n        <View style={styles.upgradeHeader}>\n          <Text style={styles.upgradeName}>{upgrade.name}</Text>\n          <Text style={styles.upgradeLevel}>Level {upgrade.currentLevel}</Text>\n        </View>\n        <Text style={styles.upgradeDescription}>{upgrade.description}</Text>\n        <View style={styles.upgradeFooter}>\n          <View style={styles.costContainer}>\n            <Text style={styles.costIcon}>üí∞</Text>\n            <Text style={styles.costText}>${cost}</Text>\n          </View>\n          <TouchableOpacity\n            style={[\n              styles.upgradeButton,\n              (!canAfford || isMaxLevel) && styles.upgradeButtonDisabled,\n            ]}\n            onPress={() => handleUpgrade(upgrade.id, cost, upgrade.currentLevel)}\n            disabled={!canAfford || isMaxLevel}\n            activeOpacity={0.7}\n          >\n            <Text style={styles.upgradeButtonText}>\n              {isMaxLevel ? 'MAX' : 'Upgrade'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n    );\n  };\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.headerTitle}>Upgrades</Text>\n        <View style={styles.balanceContainer}>\n          <Text style={styles.balanceLabel}>Balance:</Text>\n          <Text style={styles.balanceAmount}>üí∞ ${money}</Text>\n        </View>\n      </View>\n      <ScrollView style={styles.scrollView} contentContainerStyle={styles.upgradesList}>\n        {upgradesData.map((upgrade) => (\n          <UpgradeCard key={upgrade.id} upgrade={upgrade} />\n        ))}\n      </ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n  },\n  header: {\n    paddingHorizontal: 16,\n    paddingVertical: 16,\n    backgroundColor: '#2a2a2a',\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 8,\n  },\n  balanceContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  balanceLabel: {\n    fontSize: 14,\n    color: '#888',\n    fontWeight: '600',\n  },\n  balanceAmount: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n  scrollView: {\n    flex: 1,\n  },\n  upgradesList: {\n    padding: 16,\n  },\n  upgradeCard: {\n    backgroundColor: '#2a2a2a',\n    borderRadius: 12,\n    padding: 16,\n    marginBottom: 16,\n    borderWidth: 2,\n    borderColor: '#3a3a3a',\n  },\n  upgradeHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: 8,\n  },\n  upgradeName: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    flex: 1,\n  },\n  upgradeLevel: {\n    fontSize: 14,\n    color: '#10b981',\n    fontWeight: '600',\n  },\n  upgradeDescription: {\n    fontSize: 14,\n    color: '#ccc',\n    marginBottom: 12,\n    lineHeight: 20,\n  },\n  upgradeFooter: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  costContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 6,\n  },\n  costIcon: {\n    fontSize: 16,\n  },\n  costText: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n  upgradeButton: {\n    backgroundColor: '#10b981',\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    borderRadius: 6,\n  },\n  upgradeButtonDisabled: {\n    backgroundColor: '#6b7280',\n  },\n  upgradeButtonText: {\n    color: '#ffffff',\n    fontSize: 14,\n    fontWeight: 'bold',\n  },\n});\n\nexport default UpgradesScene;","size_bytes":6571},"src/Scenes/Rebirthing/RebirthCalculator.js":{"content":"// RebirthCalculator.js\nexport const REBIRTH_REQUIREMENT = 1000000;\nexport const WIPED_RARITIES = ['common', 'rare', 'legendary', 'mythic'];\nexport const PROTECTED_RARITIES = ['seasonal', 'vaulted', 'special', 'exclusive'];\n\n// Core calculations\nexport const calculateWipedValue = (inventory) => {\n  if (!inventory || !Array.isArray(inventory)) return 0;\n  \n  return inventory\n    .filter(item => item && WIPED_RARITIES.includes(item.rarity?.toLowerCase()))\n    .reduce((total, item) => total + (item.value || 0), 0);\n};\n\nexport const calculateMultiplierGain = (wipedValue) => {\n  if (wipedValue < REBIRTH_REQUIREMENT) return 0;\n  \n  const multiplierGain = 1.2 + 0.1 * Math.log2(wipedValue / REBIRTH_REQUIREMENT);\n  return multiplierGain;\n};\n\nexport const getNextMilestone = (currentValue) => {\n  const currentMultiplier = calculateMultiplierGain(currentValue);\n  const nextMultiplier = Math.floor((currentMultiplier + 0.099) * 10) / 10;\n  \n  if (nextMultiplier > 5.0) return null;\n  \n  const requiredValue = REBIRTH_REQUIREMENT * Math.pow(2, (nextMultiplier - 1.2) / 0.1);\n  return {\n    multiplier: nextMultiplier,\n    value: Math.ceil(requiredValue)\n  };\n};\n\n// Validation\nexport const canRebirth = (wipedValue) => wipedValue >= REBIRTH_REQUIREMENT;\n\n// Rebirth execution logic\nexport const performRebirth = (inventory) => {\n  if (!inventory || !Array.isArray(inventory)) return [];\n  \n  return inventory.filter(item => \n    item && PROTECTED_RARITIES.includes(item.rarity?.toLowerCase())\n  );\n};","size_bytes":1499},"src/configs/CasesConfig.js":{"content":"// Case images\nconst COMMON_CASE_IMG = require('../img/memes/PepeTheFrog.jpg');\nconst RARE_CASE_IMAGE = require('../img/memes/RickRoll.png');\nconst EPIC_CASE_IMAGE = require('../img/memes/QuandaleDingle.jpg');\nconst LEGENDARY_CASE_IMAGE = require('../img/memes/SixSeven.jpg');\n\n// Import drops config for case contents\nimport drops from './DropsConfig';\n\nconst CASES_CONFIG = [\n  {\n    id: 'common_case',\n    name: 'Common Case',\n    imageSrc: COMMON_CASE_IMG,\n    price: 1000,\n    rarity: 'common',\n    description: 'Basic case with common memes',\n    dropWeights: {\n      'Pepe the Frog': 40,\n      'Brain Overload': 25,\n      'Overly Attached Girlfriend': 20,\n      'Drake Reacts No': 10,\n      'Grumpy Cat': 5,\n      'Success Kid': 0,\n      'Quandale Dingle': 0,\n      'Original Doge': 0,\n      'This Is Fine': 0,\n      'Rick Roll': 0,\n      'SixSeven Kid': 0,\n      'Bad Luck Brian': 0,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'uncommon_case',\n    name: 'Uncommon Case',\n    imageSrc: COMMON_CASE_IMG,\n    price: 2500,\n    rarity: 'uncommon',\n    description: 'Case with better uncommon memes',\n    dropWeights: {\n      'Pepe the Frog': 25,\n      'Brain Overload': 20,\n      'Overly Attached Girlfriend': 15,\n      'Drake Reacts No': 15,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 5,\n      'Original Doge': 0,\n      'This Is Fine': 0,\n      'Rick Roll': 0,\n      'SixSeven Kid': 0,\n      'Bad Luck Brian': 0,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'rare_case',\n    name: 'Rare Case',\n    imageSrc: RARE_CASE_IMAGE,\n    price: 7500,\n    rarity: 'rare',\n    description: 'Case featuring rare meme finds',\n    dropWeights: {\n      'Pepe the Frog': 15,\n      'Brain Overload': 15,\n      'Overly Attached Girlfriend': 15,\n      'Drake Reacts No': 15,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 10,\n      'Original Doge': 8,\n      'This Is Fine': 2,\n      'Rick Roll': 0,\n      'SixSeven Kid': 0,\n      'Bad Luck Brian': 0,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'epic_case',\n    name: 'Epic Case',\n    imageSrc: EPIC_CASE_IMAGE,\n    price: 20000,\n    rarity: 'epic',\n    description: 'Epic case with valuable memes',\n    dropWeights: {\n      'Pepe the Frog': 10,\n      'Brain Overload': 10,\n      'Overly Attached Girlfriend': 10,\n      'Drake Reacts No': 15,\n      'Grumpy Cat': 15,\n      'Success Kid': 10,\n      'Quandale Dingle': 10,\n      'Original Doge': 10,\n      'This Is Fine': 8,\n      'Rick Roll': 2,\n      'SixSeven Kid': 0,\n      'Bad Luck Brian': 0,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'legendary_case',\n    name: 'Legendary Case',\n    imageSrc: LEGENDARY_CASE_IMAGE,\n    price: 50000,\n    rarity: 'legendary',\n    description: 'Legendary case with high-value drops',\n    dropWeights: {\n      'Pepe the Frog': 5,\n      'Brain Overload': 5,\n      'Overly Attached Girlfriend': 5,\n      'Drake Reacts No': 10,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 15,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 8,\n      'SixSeven Kid': 2,\n      'Bad Luck Brian': 0,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'mythic_case',\n    name: 'Mythic Case',\n    imageSrc: LEGENDARY_CASE_IMAGE,\n    price: 125000,\n    rarity: 'mythic',\n    description: 'Mythic case with ultra-rare finds',\n    dropWeights: {\n      'Pepe the Frog': 2,\n      'Brain Overload': 3,\n      'Overly Attached Girlfriend': 5,\n      'Drake Reacts No': 8,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 15,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 10,\n      'SixSeven Kid': 5,\n      'Bad Luck Brian': 2,\n      'Troll Face': 0,\n    },\n  },\n  {\n    id: 'premium_case',\n    name: 'Premium Case',\n    imageSrc: EPIC_CASE_IMAGE,\n    price: 300000,\n    rarity: 'premium',\n    description: 'Premium case with exclusive drops',\n    dropWeights: {\n      'Pepe the Frog': 0,\n      'Brain Overload': 5,\n      'Overly Attached Girlfriend': 5,\n      'Drake Reacts No': 10,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 15,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 10,\n      'SixSeven Kid': 8,\n      'Bad Luck Brian': 5,\n      'Troll Face': 2,\n    },\n  },\n  {\n    id: 'elite_case',\n    name: 'Elite Case',\n    imageSrc: RARE_CASE_IMAGE,\n    price: 750000,\n    rarity: 'elite',\n    description: 'Elite case for serious collectors',\n    dropWeights: {\n      'Pepe the Frog': 0,\n      'Brain Overload': 0,\n      'Overly Attached Girlfriend': 5,\n      'Drake Reacts No': 8,\n      'Grumpy Cat': 10,\n      'Success Kid': 10,\n      'Quandale Dingle': 15,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 12,\n      'SixSeven Kid': 10,\n      'Bad Luck Brian': 8,\n      'Troll Face': 2,\n    },\n  },\n  {\n    id: 'master_case',\n    name: 'Master Case',\n    imageSrc: LEGENDARY_CASE_IMAGE,\n    price: 1500000,\n    rarity: 'master',\n    description: 'Master case with legendary potential',\n    dropWeights: {\n      'Pepe the Frog': 0,\n      'Brain Overload': 0,\n      'Overly Attached Girlfriend': 0,\n      'Drake Reacts No': 5,\n      'Grumpy Cat': 8,\n      'Success Kid': 10,\n      'Quandale Dingle': 15,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 15,\n      'SixSeven Kid': 12,\n      'Bad Luck Brian': 10,\n      'Troll Face': 5,\n    },\n  },\n  {\n    id: 'ultimate_case',\n    name: 'Ultimate Case',\n    imageSrc: LEGENDARY_CASE_IMAGE,\n    price: 3000000,\n    rarity: 'ultimate',\n    description: 'The ultimate case for the rarest memes',\n    dropWeights: {\n      'Pepe the Frog': 0,\n      'Brain Overload': 0,\n      'Overly Attached Girlfriend': 0,\n      'Drake Reacts No': 0,\n      'Grumpy Cat': 5,\n      'Success Kid': 8,\n      'Quandale Dingle': 12,\n      'Original Doge': 15,\n      'This Is Fine': 15,\n      'Rick Roll': 15,\n      'SixSeven Kid': 15,\n      'Bad Luck Brian': 10,\n      'Troll Face': 5,\n    },\n  },\n];\n\n// Helper function to get case by ID\nexport const getCaseById = (id) => {\n  return CASES_CONFIG.find(caseItem => caseItem.id === id);\n};\n\n// Helper function to get all cases\nexport const getAllCases = () => {\n  return CASES_CONFIG;\n};\n\n// Helper function to get cases by rarity\nexport const getCasesByRarity = (rarity) => {\n  return CASES_CONFIG.filter(caseItem => caseItem.rarity === rarity);\n};\n\n// Helper function to get case drops with proper weighting\nexport const getCaseDrops = (caseId) => {\n  const caseItem = getCaseById(caseId);\n  if (!caseItem || !caseItem.dropWeights) return {};\n  \n  // Calculate percentages from weights\n  const weights = caseItem.dropWeights;\n  const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);\n  \n  const percentages = {};\n  Object.keys(weights).forEach(itemName => {\n    percentages[itemName] = weights[itemName] / totalWeight;\n  });\n  \n  return percentages;\n};\n\nexport default CASES_CONFIG;","size_bytes":6946},"src/TopBar.js":{"content":"import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\n\nconst TopBar = ({ money }) => {\n  const formatMoney = (amount) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD',\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0,\n    }).format(amount);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Case Opener</Text>\n      <View style={styles.moneyContainer}>\n        <Text style={styles.moneyIcon}>üí∞</Text>\n        <Text style={styles.moneyText}>{formatMoney(money)}</Text>\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    backgroundColor: '#2a2a2a',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.3,\n    shadowRadius: 4,\n    elevation: 6,\n  },\n  title: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#ffffff',\n  },\n  moneyContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: '#1a1a1a',\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 20,\n    borderWidth: 2,\n    borderColor: '#f59e0b',\n  },\n  moneyIcon: {\n    fontSize: 18,\n    marginRight: 6,\n  },\n  moneyText: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n});\n\nexport default TopBar;","size_bytes":1529},"src/Scenes/CaseOpening/CaseDrop.js":{"content":"import React from 'react';\nimport { View, StyleSheet, Image } from 'react-native';\n\nconst CaseDrop = ({ dropImage }) => {\n  let source;\n  if (typeof dropImage.imageSrc === 'number') {\n    source = dropImage.imageSrc;\n  } else {\n    source = { uri: dropImage.imageSrc };\n  }\n  return (\n    <View \n      style={[\n        styles.container, \n        { \n          backgroundColor: dropImage.rarityColor,\n          borderColor: dropImage.rarityColor,\n        }\n      ]}\n    >\n      <Image \n        source={source}\n        style={styles.dropImage}\n        resizeMode=\"contain\"\n        onError={(error) => console.log('Image loading error:', error)}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 12,\n    borderRadius: 8,\n    borderWidth: 4,\n    width: 120,\n    height: 120,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  dropImage: {\n    width: '100%',\n    height: '100%',\n  },\n});\n\nexport default CaseDrop;","size_bytes":962},"src/DataStorage.js":{"content":"import AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst STORAGE_KEYS = {\n  MONEY: '@user_money',\n  INVENTORY: '@user_inventory',\n  UPGRADES: '@user_upgrades',\n  REBIRTH_MULTIPLIER: '@rebirth_multiplier',\n  TOTAL_REBIRTHS: '@total_rebirths',\n};\n\n// Helper function to validate and fix numbers\nconst validateNumber = (value, defaultValue = 0) => {\n  if (value === null || value === undefined) return defaultValue;\n  \n  const num = parseFloat(value);\n  if (isNaN(num) || !isFinite(num)) {\n    return defaultValue;\n  }\n  return num;\n};\n\n// Money operations - FIXED to ensure proper persistence\nexport const getMoney = async () => {\n  try {\n    const value = await AsyncStorage.getItem(STORAGE_KEYS.MONEY);\n    if (value !== null) {\n      const parsed = validateNumber(value, 1000);\n      // If we got NaN and had to use default, save the corrected value\n      if (isNaN(parseFloat(value)) || !isFinite(parseFloat(value))) {\n        console.log('Fixed corrupted money value:', value, '-> 1000');\n        await AsyncStorage.setItem(STORAGE_KEYS.MONEY, '1000');\n        return 1000;\n      }\n      return parsed;\n    }\n    // Initialize with default money if not exists\n    await AsyncStorage.setItem(STORAGE_KEYS.MONEY, '1000');\n    return 1000;\n  } catch (error) {\n    console.error('Error getting money:', error);\n    return 1000;\n  }\n};\n\nexport const setMoney = async (amount) => {\n  try {\n    const validAmount = validateNumber(amount, 0);\n    await AsyncStorage.setItem(STORAGE_KEYS.MONEY, validAmount.toString());\n    console.log('Money saved to storage:', validAmount); // Debug log\n    return true;\n  } catch (error) {\n    console.error('Error setting money:', error);\n    return false;\n  }\n};\n\nexport const addMoney = async (amount) => {\n  try {\n    const currentMoney = await getMoney();\n    const validAmount = validateNumber(amount, 0);\n    const newMoney = validateNumber(currentMoney + validAmount, 0);\n    await setMoney(newMoney);\n    return newMoney;\n  } catch (error) {\n    console.error('Error adding money:', error);\n    return null;\n  }\n};\n\nexport const subtractMoney = async (amount) => {\n  try {\n    const currentMoney = await getMoney();\n    const validAmount = validateNumber(amount, 0);\n    if (currentMoney >= validAmount) {\n      const newMoney = validateNumber(currentMoney - validAmount, 0);\n      await setMoney(newMoney);\n      return newMoney;\n    }\n    return null; // Not enough money\n  } catch (error) {\n    console.error('Error subtracting money:', error);\n    return null;\n  }\n};\n\n// Inventory operations\nexport const getInventory = async () => {\n  try {\n    const value = await AsyncStorage.getItem(STORAGE_KEYS.INVENTORY);\n    return value !== null ? JSON.parse(value) : [];\n  } catch (error) {\n    console.error('Error getting inventory:', error);\n    return [];\n  }\n};\n\nexport const setInventory = async (inventory) => {\n  try {\n    await AsyncStorage.setItem(STORAGE_KEYS.INVENTORY, JSON.stringify(inventory));\n    return true;\n  } catch (error) {\n    console.error('Error setting inventory:', error);\n    return false;\n  }\n};\n\nexport const addToInventory = async (item) => {\n  try {\n    const inventory = await getInventory();\n    inventory.push(item);\n    await setInventory(inventory);\n    return true;\n  } catch (error) {\n    console.error('Error adding to inventory:', error);\n    return false;\n  }\n};\n\nexport const removeFromInventory = async (toRemove) => {\n  try {\n    const inventory = await getInventory();\n    const idx = inventory.findIndex((item) =>\n      item.id === toRemove.id && item.acquiredAt === toRemove.acquiredAt\n    );\n    if (idx > -1) {\n      inventory.splice(idx, 1);\n      await setInventory(inventory);\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Error removing from inventory:', error);\n    return false;\n  }\n};\n\n// Upgrade operations\nexport const getUpgrades = async () => {\n  try {\n    const value = await AsyncStorage.getItem(STORAGE_KEYS.UPGRADES);\n    if (value !== null) {\n      const parsed = JSON.parse(value);\n      \n      // Validate all numeric fields including autoClickPower\n      const validated = {\n        caseSpeed: validateNumber(parsed.caseSpeed, 0),\n        clickerPower: validateNumber(parsed.clickerPower, 0),\n        autoClickPower: validateNumber(parsed.autoClickPower, 0),\n        rebirthMultiplier: validateNumber(parsed.rebirthMultiplier, 1),\n        totalRebirths: validateNumber(parsed.totalRebirths, 0),\n      };\n      \n      // Check if any values were corrupted (NaN)\n      const needsCorrection = \n        (parsed.caseSpeed !== undefined && (isNaN(parseFloat(parsed.caseSpeed)) || !isFinite(parsed.caseSpeed))) ||\n        (parsed.clickerPower !== undefined && (isNaN(parseFloat(parsed.clickerPower)) || !isFinite(parsed.clickerPower))) ||\n        (parsed.autoClickPower !== undefined && (isNaN(parseFloat(parsed.autoClickPower)) || !isFinite(parsed.autoClickPower))) ||\n        (parsed.rebirthMultiplier !== undefined && (isNaN(parseFloat(parsed.rebirthMultiplier)) || !isFinite(parsed.rebirthMultiplier))) ||\n        (parsed.totalRebirths !== undefined && (isNaN(parseFloat(parsed.totalRebirths)) || !isFinite(parsed.totalRebirths)));\n      \n      if (needsCorrection) {\n        console.log('Fixed corrupted upgrades. Original:', parsed, 'Fixed:', validated);\n        await AsyncStorage.setItem(STORAGE_KEYS.UPGRADES, JSON.stringify(validated));\n      }\n      \n      return validated;\n    }\n    \n    // Default upgrades\n    const defaults = {\n      caseSpeed: 0,\n      clickerPower: 0,\n      autoClickPower: 0,\n      rebirthMultiplier: 1,\n      totalRebirths: 0,\n    };\n    await AsyncStorage.setItem(STORAGE_KEYS.UPGRADES, JSON.stringify(defaults));\n    return defaults;\n  } catch (error) {\n    console.error('Error getting upgrades:', error);\n    const defaults = {\n      caseSpeed: 0,\n      clickerPower: 0,\n      autoClickPower: 0,\n      rebirthMultiplier: 1,\n      totalRebirths: 0,\n    };\n    await AsyncStorage.setItem(STORAGE_KEYS.UPGRADES, JSON.stringify(defaults));\n    return defaults;\n  }\n};\n\nexport const setUpgrades = async (upgrades) => {\n  try {\n    const validated = {\n      caseSpeed: validateNumber(upgrades.caseSpeed, 0),\n      clickerPower: validateNumber(upgrades.clickerPower, 0),\n      autoClickPower: validateNumber(upgrades.autoClickPower, 0),\n      rebirthMultiplier: validateNumber(upgrades.rebirthMultiplier, 1),\n      totalRebirths: validateNumber(upgrades.totalRebirths, 0),\n    };\n    await AsyncStorage.setItem(STORAGE_KEYS.UPGRADES, JSON.stringify(validated));\n    return true;\n  } catch (error) {\n    console.error('Error setting upgrades:', error);\n    return false;\n  }\n};\n\n// Clear all data (for testing)\nexport const clearAllData = async () => {\n  try {\n    await AsyncStorage.clear();\n    return true;\n  } catch (error) {\n    console.error('Error clearing data:', error);\n    return false;\n  }\n};\n\n// Auto-fix corrupted data\nexport const fixCorruptedData = async () => {\n  try {\n    console.log('Running corruption check and auto-fix...');\n    await getMoney();\n    await getUpgrades();\n    console.log('Corruption check complete');\n    return true;\n  } catch (error) {\n    console.error('Error fixing corrupted data:', error);\n    return false;\n  }\n};\n\nexport default {\n  getMoney,\n  setMoney,\n  addMoney,\n  subtractMoney,\n  getInventory,\n  setInventory,\n  addToInventory,\n  removeFromInventory,\n  getUpgrades,\n  setUpgrades,\n  clearAllData,\n  fixCorruptedData,\n};","size_bytes":7464},"src/configs/DropsConfig.js":{"content":"// Export meme drop config based on files in src/img/memes\n\n// Rarity color defined for visual ease ...\n// upon rarity of \"Seasonal\", when implemented, would otherwise be problematic.\n\nconst drops = [\n  {\n    name: 'Pepe the Frog',\n    imageSrc: require('../img/memes/PepeTheFrog.jpg'),\n    rarity: 'Common',\n    rarityColor: '#b8a01a',\n    value: 289,\n  },\n  {\n    name: 'Brain Overload',\n    imageSrc: require('../img/memes/BrainOverload.jpg'),\n    rarity: 'Common',\n    rarityColor: '#b8a01a',\n    value: 655,\n  },\n  {\n    name: 'Overly Attached Girlfriend',\n    imageSrc: require('../img/memes/OverlyAttachedGirlfriend.jpg'),\n    rarity: 'Common',\n    rarityColor: '#b8a01a',\n    value: 844,\n  },\n  {\n    name: 'Drake Reacts No',\n    imageSrc: require('../img/memes/DrakeReactsNo.jpg'),\n    rarity: 'Uncommon',\n    rarityColor: '#4169e1',\n    value: 4444,\n  },\n  {\n    name: 'Grumpy Cat',\n    imageSrc: require('../img/memes/GrumpyCat.jpg'),\n    rarity: 'Uncommon',\n    rarityColor: '#4169e1',\n    value: 6666,\n  },\n  {\n    name: 'Success Kid',\n    imageSrc: require('../img/memes/SuccessKid.jpg'),\n    rarity: 'Uncommon',\n    rarityColor: '#4169e1',\n    value: 7777,\n  },\n  \n  {\n    name: 'Quandale Dingle',\n    imageSrc: require('../img/memes/QuandaleDingle.jpg'),\n    rarity: 'Rare',\n    rarityColor: '#4169e1',\n    value: 45678,\n  },\n  {\n    name: 'Original Doge',\n    imageSrc: require('../img/memes/OriginalDoge.jpg'),\n    rarity: 'Rare',\n    rarityColor: '#4169e1',\n    value: 69696,\n  },\n  {\n    name: 'This Is Fine',\n    imageSrc: require('../img/memes/ThisIsFine.jpg'),\n    rarity: 'Epic',\n    rarityColor: '#d946ef',\n    value: 141699,\n  },\n  {\n    name: 'Rick Roll',\n    imageSrc: require('../img/memes/RickRoll.png'),\n    rarity: 'Legendary',\n    rarityColor: '#d946ef',\n    value: 734265,\n  },\n  {\n    name: 'SixSeven Kid',\n    imageSrc: require('../img/memes/SixSeven.jpg'),\n    rarity: 'Mythic',\n    rarityColor: '#ef4444',\n    value: 6767676,\n  },{\n    name: 'Bad Luck Brian',\n    imageSrc: require('../img/memes/BadLuckBrian.jpg'),\n    rarity: 'Mythic',\n    rarityColor: '#FF0000',\n    value: 8101989, // the year brian was born... 08/10/89 (M/D/Y)\n  },\n  {\n    name: 'Troll Face',\n    imageSrc: require('../img/memes/TrollFace.jpg'),\n    rarity: 'Mythic',\n    rarityColor: '#ef4444',\n    value: 9192009, // Date created 09/19/2009\n  },\n];\n\nexport default drops;\n","size_bytes":2385},"src/BottomNavBar.js":{"content":"import React from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity } from 'react-native';\n\nconst NavButton = ({ icon, label, scene, activeScene, onPress }) => (\n  <TouchableOpacity\n    style={styles.navButton}\n    onPress={() => onPress(scene)}\n    activeOpacity={0.7}\n  >\n    <View style={[\n      styles.iconContainer,\n      activeScene === scene && styles.iconContainerActive\n    ]}>\n      <Text style={[\n        styles.icon,\n        activeScene === scene && styles.iconActive\n      ]}>\n        {icon}\n      </Text>\n    </View>\n    <Text style={[\n      styles.navLabel,\n      activeScene === scene && styles.navLabelActive\n    ]}>\n      {label}\n    </Text>\n  </TouchableOpacity>\n);\n\nconst BottomNavBar = ({ activeScene, onSceneChange }) => {\n  return (\n    <View style={styles.bottomBar}>\n      <NavButton\n        icon=\"üì¶\"\n        label=\"Inventory\"\n        scene=\"inventory\"\n        activeScene={activeScene}\n        onPress={onSceneChange}\n      />\n      <NavButton\n        icon=\"üîß\"\n        label=\"Upgrades\"\n        scene=\"upgrades\"\n        activeScene={activeScene}\n        onPress={onSceneChange}\n      />\n      <NavButton\n        icon=\"üéÅ\"\n        label=\"Cases\"\n        scene=\"cases\"\n        activeScene={activeScene}\n        onPress={onSceneChange}\n      />\n      <NavButton\n        icon=\"üî•\"\n        label=\"Rebirth\"\n        scene=\"rebirth\"\n        activeScene={activeScene}\n        onPress={onSceneChange}\n      />\n      <NavButton\n        icon=\"üë§\"\n        label=\"Profile\"\n        scene=\"profile\"\n        activeScene={activeScene}\n        onPress={onSceneChange}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  bottomBar: {\n    flexDirection: 'row',\n    backgroundColor: '#2a2a2a',\n    borderTopWidth: 1,\n    borderTopColor: '#3a3a3a',\n    paddingBottom: 8,\n    paddingTop: 8,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: -2 },\n    shadowOpacity: 0.3,\n    shadowRadius: 8,\n    elevation: 10,\n  },\n  navButton: {\n    flex: 1,\n    alignItems: 'center',\n    paddingVertical: 8,\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'transparent',\n    marginBottom: 4,\n  },\n  iconContainerActive: {\n    backgroundColor: '#f59e0b',\n  },\n  icon: {\n    fontSize: 24,\n  },\n  iconActive: {\n    transform: [{ scale: 1.1 }],\n  },\n  navLabel: {\n    fontSize: 12,\n    color: '#888',\n    fontWeight: '600',\n  },\n  navLabelActive: {\n    color: '#f59e0b',\n    fontWeight: 'bold',\n  },\n});\n\nexport default BottomNavBar;","size_bytes":2570},"src/Scenes/Shop.js":{"content":"import React from 'react';\nimport { View, Text, StyleSheet, ScrollView, Image, TouchableOpacity } from 'react-native';\nimport { subtractMoney } from '../DataStorage';\nimport { getAllCases } from '../configs/CasesConfig';\n\nconst CaseCard = ({ caseData, userMoney, onBuy }) => {\n  const canAfford = userMoney >= caseData.price;\n  return (\n    <View style={styles.caseCard}>\n      <View style={styles.caseImageContainer}>\n        <Image source={caseData.imageSrc} style={styles.caseImage} resizeMode=\"contain\" />\n      </View>\n      <Text style={styles.caseName}>{caseData.name}</Text>\n      <View style={styles.priceContainer}>\n        <Text style={styles.priceIcon}>üí∞</Text>\n        <Text style={styles.priceText}>${caseData.price}</Text>\n      </View>\n      <TouchableOpacity\n        style={[styles.buyButton, !canAfford && styles.buyButtonDisabled]}\n        onPress={() => canAfford && onBuy(caseData)}\n        disabled={!canAfford}\n        activeOpacity={0.7}\n      >\n        <Text style={styles.buyButtonText}>\n          {canAfford ? 'Purchase and Open' : 'Insufficient Funds'}\n        </Text>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\nconst CaseShop = ({ money, updateMoney, onCaseBought }) => {\n  const handleBuy = async (caseData) => {\n    if (!caseData || money < caseData.price) return;\n    \n    // Create proper case data structure for ScrollFrame\n    const caseForOpening = {\n      ...caseData,\n      dropWeights: caseData.dropWeights // Ensure dropWeights is included\n    };\n    \n    const newMoney = await subtractMoney(caseData.price);\n    if (newMoney !== null) {\n      updateMoney(newMoney);\n      if (onCaseBought) {\n        onCaseBought(caseForOpening); // Pass the complete case data\n      }\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.headerTitle}>Case Shop</Text>\n        <View style={styles.balanceContainer}>\n          <Text style={styles.balanceLabel}>Balance:</Text>\n          <Text style={styles.balanceAmount}>üí∞ ${money}</Text>\n        </View>\n      </View>\n      <ScrollView style={styles.scrollView} contentContainerStyle={styles.shopGrid}>\n        {getAllCases().map((caseProduct) => (\n          <CaseCard\n            key={caseProduct.id}\n            caseData={caseProduct}\n            userMoney={money}\n            onBuy={handleBuy}\n          />\n        ))}\n      </ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n  },\n  header: {\n    paddingHorizontal: 16,\n    paddingVertical: 16,\n    backgroundColor: '#2a2a2a',\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 8,\n  },\n  balanceContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  balanceLabel: {\n    fontSize: 14,\n    color: '#888',\n    fontWeight: '600',\n  },\n  balanceAmount: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n  scrollView: {\n    flex: 1,\n  },\n  shopGrid: {\n    padding: 16,\n  },\n  caseCard: {\n    backgroundColor: '#2a2a2a',\n    borderRadius: 12,\n    padding: 16,\n    marginBottom: 16,\n    borderWidth: 2,\n    borderColor: '#3a3a3a',\n  },\n  caseImageContainer: {\n    width: '100%',\n    height: 150,\n    backgroundColor: '#1a1a1a',\n    borderRadius: 8,\n    marginBottom: 12,\n    padding: 16,\n  },\n  caseImage: {\n    width: '100%',\n    height: '100%',\n  },\n  caseName: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 8,\n    textAlign: 'center',\n  },\n  priceContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginBottom: 12,\n    gap: 6,\n  },\n  priceIcon: {\n    fontSize: 18,\n  },\n  priceText: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#f59e0b',\n  },\n  buyButton: {\n    backgroundColor: '#f59e0b',\n    paddingVertical: 12,\n    borderRadius: 8,\n  },\n  buyButtonDisabled: {\n    backgroundColor: '#6b7280',\n  },\n  buyButtonText: {\n    color: '#ffffff',\n    fontSize: 16,\n    fontWeight: 'bold',\n    textAlign: 'center',\n  },\n});\n\nexport default CaseShop;","size_bytes":4186},"App.js":{"content":"import React, { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  SafeAreaView,\n} from 'react-native';\nimport ScrollFrame from './src/Scenes/CaseOpening/ScrollFrame';\nimport BottomNavBar from './src/BottomNavBar';\nimport TopBar from './src/TopBar';\nimport InventoryScene from './src/Scenes/Inventory';\nimport CaseShop from './src/Scenes/Shop';\nimport ClickerButton from './src/ClickerButton';\nimport UpgradesScene from './src/Scenes/Upgrades';\nimport { getMoney, setMoney as setMoneyStorage, getUpgrades, fixCorruptedData } from './src/DataStorage';\nimport RebirthScene from './src/Scenes/Rebirthing/Rebirth';\n\nconst ProfileScene = () => (\n  <View style={styles.sceneContainer}>\n    <Text style={styles.sceneText}>Profile Scene</Text>\n  </View>\n);\n\nconst App = () => {\n  const [mainScene, setMainScene] = useState('caseshop');\n  const [money, setMoney] = useState(1000);\n  const [openingCase, setOpeningCase] = useState(false);\n  const [showResult, setShowResult] = useState(false);\n  const [currentCase, setCurrentCase] = useState(null);\n\n  // Upgrade states\n  const [clickerPower, setClickerPower] = useState(1);\n  const [caseSpeed, setCaseSpeed] = useState(10);\n  const [rebirthMultiplier, setRebirthMultiplier] = useState(1);\n  const [autoClickPower, setAutoClickPower] = useState(0);\n\n  // Load money and upgrades on app start with corruption fix\n  useEffect(() => {\n    initializeApp();\n  }, []);\n\n  const initializeApp = async () => {\n    // First fix any corrupted data\n    await fixCorruptedData();\n    \n    // Then load the corrected data\n    await loadMoney();\n    await loadUpgrades();\n  };\n\n  const loadMoney = async () => {\n    const currentMoney = await getMoney();\n    setMoney(currentMoney);\n  };\n\n  // Helper to persist both memory and storage\n  const persistMoney = async (newAmount) => {\n    setMoney(newAmount);\n    await setMoneyStorage(newAmount);\n  };\n\n  const openCaseFromShop = (caseData) => {\n    console.log('Opening case:', caseData); // Debug log\n    setCurrentCase(caseData);\n    setOpeningCase(true);\n    setMainScene('caseopening'); // Set a dedicated scene for case opening\n  };\n\n  // Handlers after roll result actions\n  const handleInventory = () => {\n    setOpeningCase(false);\n    setMainScene('inventory');\n  };\n  \n  const handleSell = () => {\n    setOpeningCase(false);\n    setMainScene('caseshop'); // Return to shop after selling\n  };\n  \n  const handleFinish = () => {\n    setOpeningCase(false);\n    setMainScene('caseshop'); // Return to shop after finishing\n  };\n\n  // Instead of setMoney, use persistMoney in these functions\n  const updateMoney = (newAmount) => {\n    persistMoney(newAmount);\n  };\n\n  const handleEarnMoney = async (amount) => {\n    if (!amount) return;\n    const newMoney = money + amount;\n    setMoney(newMoney);\n    await setMoneyStorage(newMoney); // Ensure immediate persistence\n  };\n\n  // Load upgrades including auto clicker\n  const loadUpgrades = async () => {\n    const upgrades = await getUpgrades();\n    setClickerPower(1 + upgrades.clickerPower);\n    setRebirthMultiplier(upgrades.rebirthMultiplier || 1);\n    setAutoClickPower(upgrades.autoClickPower || 0);\n    \n    // Calculate case speed: 10 - (upgrades * 0.1), minimum 3.5\n    const baseSpeed = 10;\n    const reduction = upgrades.caseSpeed * 0.1;\n    const newSpeed = Math.max(3.5, baseSpeed - reduction);\n    setCaseSpeed(newSpeed);\n  };\n\n  const handleClickerPress = () => {\n    // Apply rebirth multiplier to clicker earnings\n    const earnAmount = Math.floor(clickerPower * rebirthMultiplier);\n    persistMoney(money + earnAmount);\n  };\n\n  const renderScene = () => {\n    if (openingCase) {\n      return (\n        <ScrollFrame \n          money={money} \n          updateMoney={updateMoney} \n          onFinish={handleFinish} \n          onInventory={handleInventory} \n          onSell={handleSell} \n          onShowResultChange={setShowResult} \n          caseSpeed={caseSpeed} \n          caseData={currentCase} \n        />\n      );\n    }\n    \n    switch (mainScene) {\n      case 'inventory':\n        return <InventoryScene onEarnMoney={handleEarnMoney} />;\n      case 'caseshop':\n        return <CaseShop money={money} updateMoney={updateMoney} onCaseBought={openCaseFromShop} />;\n      case 'upgrades':\n        return <UpgradesScene money={money} updateMoney={updateMoney} onUpgradePurchased={loadUpgrades} />;\n      case 'rebirth':\n        return <RebirthScene money={money} updateMoney={updateMoney} onUpgradePurchased={loadUpgrades} />;\n      case 'profile':\n        return <ProfileScene />;\n      default:\n        return <CaseShop money={money} updateMoney={updateMoney} onCaseBought={openCaseFromShop} />;\n    }\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* Top bar */}\n      <TopBar money={money} />\n\n      {/* Main content area */}\n      <View style={styles.content}>\n        {renderScene()}\n      </View>\n\n      {/* Clicker button with auto clicker functionality */}\n      <ClickerButton \n        onPress={handleClickerPress} \n        clickerPower={clickerPower}\n        rebirthMultiplier={rebirthMultiplier}\n        autoClickPower={autoClickPower}\n      />\n\n      {/* Bottom navigation bar */}\n      <BottomNavBar\n        activeScene={mainScene}\n        onSceneChange={key => {\n          if (key === 'cases') {\n            setOpeningCase(false);\n            setMainScene('caseshop');\n            return;\n          }\n          if (openingCase) {\n            if (showResult) {\n              setOpeningCase(false);\n              setMainScene(key);\n            }\n            return;\n          }\n          setMainScene(key);\n        }}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n  },\n  content: {\n    flex: 1,\n  },\n  sceneContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#1a1a1a',\n  },\n  sceneText: {\n    fontSize: 24,\n    color: '#ffffff',\n    fontWeight: 'bold',\n  },\n});\n\nexport default App;","size_bytes":6026},"src/Scenes/Inventory.js":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, ScrollView, Image, TouchableOpacity, Animated, Modal } from 'react-native';\nimport { getInventory, setInventory, getUpgrades } from '../DataStorage';\n\nconst InventoryItem = ({ item, onPress, onLongPress, selected, selectionMode, fadeAnim, onImageLoad }) => {\n  let source;\n  if (typeof item.imageSrc === 'number') {\n    source = item.imageSrc;\n  } else {\n    source = { uri: item.imageSrc };\n  }\n  return (\n    <Animated.View style={[styles.itemCard, { borderColor: selected ? '#f59e0b' : item.rarityColor, opacity: fadeAnim }]}>   \n      <TouchableOpacity\n        style={[styles.itemImageContainer, { backgroundColor: item.rarityColor, opacity: selectionMode && !selected ? 0.4 : 1 }]}\n        onPress={onPress}\n        onLongPress={onLongPress}\n        delayLongPress={320}\n        activeOpacity={0.8}\n      >\n        <Image \n          source={source}\n          style={styles.itemImage}\n          resizeMode=\"contain\"\n          onLoad={onImageLoad}\n        />\n        {selectionMode && selected && (\n          <View style={styles.selectedOverlay}><Text style={styles.selectedText}>‚úì</Text></View>\n        )}\n      </TouchableOpacity>\n    </Animated.View>\n  );\n};\n\nconst InventoryScene = ({ onEarnMoney }) => {\n  const [inventory, setInventoryState] = useState([]);\n  const [sortBy, setSortBy] = useState('none');\n  const [filterRarity, setFilterRarity] = useState('all');\n  const [showSortMenu, setShowSortMenu] = useState(false);\n  const [showRarityMenu, setShowRarityMenu] = useState(false);\n  const [modalItem, setModalItem] = useState(null);\n  const [selectMode, setSelectMode] = useState(false);\n  const [selected, setSelected] = useState([]);\n  const [itemLoaded, setItemLoaded] = useState({});\n  const [rebirthMultiplier, setRebirthMultiplier] = useState(1);\n  // For animation\n  const fadeAnimMap = React.useRef({});\n\n  useEffect(() => { \n    loadInventory();\n    loadRebirthMultiplier();\n  }, []);\n\n  const loadInventory = async () => {\n    const items = await getInventory();\n    setInventoryState(items);\n  };\n\n  const loadRebirthMultiplier = async () => {\n    const upgrades = await getUpgrades();\n    setRebirthMultiplier(upgrades.rebirthMultiplier || 1);\n  };\n\n  const saveInventory = async (items) => {\n    setInventoryState(items);\n    await setInventory(items);\n  };\n\n  const getFilteredAndSortedInventory = () => {\n    let items = [...inventory];\n    if (filterRarity !== 'all') {\n      items = items.filter(item => item.rarity === filterRarity);\n    }\n    switch (sortBy) {\n      case 'value-asc':\n        items.sort((a, b) => (a.value || 0) - (b.value || 0));\n        break;\n      case 'value-desc':\n        items.sort((a, b) => (b.value || 0) - (a.value || 0));\n        break;\n      case 'name-asc':\n        items.sort((a, b) => a.name.localeCompare(b.name));\n        break;\n      case 'name-desc':\n        items.sort((a, b) => b.name.localeCompare(a.name));\n        break;\n    }\n    return items;\n  };\n\n  const filteredInventory = getFilteredAndSortedInventory();\n\n  // Multiselect logic\n  const toggleSelectMode = () => {\n    setSelectMode(!selectMode); setSelected([]); setModalItem(null);\n  };\n  const handleSelect = (idx) => {\n    setSelected(sel => sel.includes(idx) ? sel.filter(i => i !== idx) : [...sel, idx]);\n  };\n  const handleSelectAll = () => {\n    if (selected.length === filteredInventory.length) {\n      setSelected([]);\n    } else {\n      setSelected(filteredInventory.map((_,i) => i));\n    }\n  };\n  const deleteSelected = async () => {\n    const toDelete = selected.map(i => filteredInventory[i]);\n    const baseEarned = toDelete.reduce((sum, item) => sum + (item.value || 0), 0);\n    const earnedWithMultiplier = Math.floor(baseEarned * rebirthMultiplier);\n    const newInventory = inventory.filter(invItem => !toDelete.some(selItem=>selItem.acquiredAt===invItem.acquiredAt));\n    await saveInventory(newInventory);\n    setSelected([]); setSelectMode(false);\n    if (onEarnMoney && earnedWithMultiplier > 0) onEarnMoney(earnedWithMultiplier);\n  };\n  const deleteModalItem = async () => {\n    if (!modalItem) return;\n    const baseEarned = modalItem.value || 0;\n    const earnedWithMultiplier = Math.floor(baseEarned * rebirthMultiplier);\n    const newInventory = inventory.filter(invItem => invItem.acquiredAt!==modalItem.acquiredAt);\n    await saveInventory(newInventory);\n    setModalItem(null);\n    if (onEarnMoney && earnedWithMultiplier > 0) onEarnMoney(earnedWithMultiplier);\n  };\n  // Animated fade-in for all items, but only after image load\n  const makeFadeAnim = (idx) => {\n    if (!fadeAnimMap.current[idx]) fadeAnimMap.current[idx] = new Animated.Value(0);\n    return fadeAnimMap.current[idx];\n  };\n  const onCardImageLoad = (idx) => {\n    setItemLoaded(s => ({ ...s, [idx]: true }));\n    Animated.timing(fadeAnimMap.current[idx], {\n      toValue: 1,\n      duration: 160,\n      useNativeDriver: true,\n    }).start();\n  };\n\n  // Compute live value sum with multiplier\n  const selectedBaseValue = selectMode\n    ? selected\n        .map(i => filteredInventory[i])\n        .reduce((sum, item) => sum + (item?.value || 0), 0)\n    : 0;\n  const selectedValue = Math.floor(selectedBaseValue * rebirthMultiplier);\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.filterBar}>\n        <TouchableOpacity\n          style={[styles.dropdownButton, selectMode && {backgroundColor: '#f59e0b'}]}\n          onPress={toggleSelectMode}\n          activeOpacity={0.7}\n        >\n          <Text style={{color: selectMode ? '#fff' : '#f59e0b', fontWeight:'bold'}}>\n            {selectMode ? 'Cancel' : 'Select'}\n          </Text>\n        </TouchableOpacity>\n        {selectMode && (\n          <TouchableOpacity style={styles.dropdownButton} onPress={handleSelectAll} activeOpacity={0.7}>\n            <Text style={{color:'#fff'}}>Select All</Text>\n          </TouchableOpacity>\n        )}\n        {selectMode && (\n          <TouchableOpacity style={[styles.dropdownButton, {backgroundColor:'#10b981'}]} onPress={deleteSelected} activeOpacity={0.8}>\n            <Text style={{color:'#fff'}}>\n              Sell: ${selectedValue}\n              {rebirthMultiplier > 1 && (\n                <Text style={{fontSize: 11}}> ({rebirthMultiplier.toFixed(2)}x)</Text>\n              )}\n            </Text>\n          </TouchableOpacity>\n        )}\n        {!selectMode && (\n          <>\n            <View style={styles.dropdownContainer}>\n              <TouchableOpacity \n                style={styles.dropdownButton}\n                onPress={() => {\n                  setShowSortMenu(!showSortMenu);\n                  setShowRarityMenu(false);\n                }}\n                activeOpacity={0.7}\n              >\n                <Text style={styles.dropdownIcon}>‚¨ÜÔ∏è‚¨áÔ∏è</Text>\n                <Text style={styles.dropdownText}>Sort</Text>\n              </TouchableOpacity>\n              \n              {showSortMenu && (\n                <View style={styles.dropdownMenu}>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setSortBy('value-asc');\n                      setShowSortMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Value ‚¨ÜÔ∏è</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setSortBy('value-desc');\n                      setShowSortMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Value ‚¨áÔ∏è</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setSortBy('name-asc');\n                      setShowSortMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Name A-Z</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setSortBy('name-desc');\n                      setShowSortMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Name Z-A</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setSortBy('none');\n                      setShowSortMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>None</Text>\n                  </TouchableOpacity>\n                </View>\n              )}\n            </View>\n\n            {/* Rarity Filter Dropdown */}\n            <View style={styles.dropdownContainer}>\n              <TouchableOpacity \n                style={styles.dropdownButton}\n                onPress={() => {\n                  setShowRarityMenu(!showRarityMenu);\n                  setShowSortMenu(false);\n                }}\n                activeOpacity={0.7}\n              >\n                <Text style={styles.dropdownIcon}>‚ú®</Text>\n                <Text style={styles.dropdownText}>Rarity</Text>\n              </TouchableOpacity>\n              \n              {showRarityMenu && (\n                <View style={styles.dropdownMenu}>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setFilterRarity('all');\n                      setShowRarityMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>All</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setFilterRarity('Common');\n                      setShowRarityMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Common</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setFilterRarity('Rare');\n                      setShowRarityMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Rare</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setFilterRarity('Epic');\n                      setShowRarityMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Epic</Text>\n                  </TouchableOpacity>\n                  <TouchableOpacity \n                    style={styles.menuItem}\n                    onPress={() => {\n                      setFilterRarity('Legendary');\n                      setShowRarityMenu(false);\n                    }}\n                  >\n                    <Text style={styles.menuItemText}>Legendary</Text>\n                  </TouchableOpacity>\n                </View>\n              )}\n            </View>\n            <Text style={styles.itemCount}>{filteredInventory.length} items</Text>\n          </>\n        )}\n      </View>\n      {/* Inventory Grid */}\n      {filteredInventory.length > 0 ? (\n        <ScrollView style={styles.scrollView} contentContainerStyle={styles.inventoryGrid}>\n          {filteredInventory.map((item, idx) => (\n            <InventoryItem\n              key={item.acquiredAt || idx}\n              item={item}\n              selected={selectMode && selected.includes(idx)}\n              selectionMode={selectMode}\n              onPress={()=>{\n                if (selectMode) handleSelect(idx);\n                else setModalItem(item);\n              }}\n              onLongPress={()=>setSelectMode(true)}\n              fadeAnim={makeFadeAnim(idx)}\n              onImageLoad={()=>onCardImageLoad(idx)}\n            />\n          ))}\n        </ScrollView>\n      ) : (\n        <View style={styles.emptyContainer}>\n          <Text style={styles.emptyIcon}>üì¶</Text>\n          <Text style={styles.emptyText}>No items found</Text>\n        </View>\n      )}\n\n      {/* Modal for single item view */}\n      <Modal visible={!!modalItem} transparent animationType=\"fade\" onRequestClose={()=>setModalItem(null)}>\n        <View style={styles.modalOverlay}>\n          <View style={styles.modalContent}>\n            {modalItem && <>\n              <Image\n                source={typeof modalItem.imageSrc==='number' ? modalItem.imageSrc : {uri: modalItem.imageSrc}}\n                style={styles.modalImage}\n                resizeMode=\"contain\"\n              />\n              <Text style={styles.modalTitle}>{modalItem.name}</Text>\n              <Text style={styles.modalMeta}>Rarity: <Text style={{color:modalItem.rarityColor}}>{modalItem.rarity}</Text></Text>\n              {modalItem.value!=null && (\n                <Text style={styles.modalMeta}>\n                  Value: ${Math.floor((modalItem.value || 0) * rebirthMultiplier)}\n                  {rebirthMultiplier > 1 && (\n                    <Text style={styles.multiplierText}> ({rebirthMultiplier.toFixed(2)}x)</Text>\n                  )}\n                </Text>\n              )}\n              <TouchableOpacity style={styles.modalDelete} onPress={deleteModalItem} activeOpacity={0.8}>\n                <Text style={{color:'#fff'}}>\n                  Sell Item For ${Math.floor((modalItem.value || 0) * rebirthMultiplier)}\n                  {rebirthMultiplier > 1 && (\n                    <Text style={{fontSize: 12}}> ({rebirthMultiplier.toFixed(2)}x)</Text>\n                  )}\n                </Text>\n              </TouchableOpacity>\n            </>}\n            <TouchableOpacity style={styles.modalClose} onPress={()=>setModalItem(null)} activeOpacity={0.7}><Text style={{color:'#f59e0b'}}>Close</Text></TouchableOpacity>\n          </View>\n        </View>\n      </Modal>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#1a1a1a',\n  },\n  filterBar: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    backgroundColor: '#2a2a2a',\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n    gap: 12,\n  },\n  dropdownContainer: {\n    position: 'relative',\n    zIndex: 1000,\n  },\n  dropdownButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: '#1a1a1a',\n    paddingHorizontal: 12,\n    paddingVertical: 8,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#3a3a3a',\n    gap: 6,\n  },\n  dropdownIcon: {\n    fontSize: 16,\n  },\n  dropdownText: {\n    color: '#ffffff',\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  dropdownMenu: {\n    position: 'absolute',\n    top: 42,\n    left: 0,\n    backgroundColor: '#2a2a2a',\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#3a3a3a',\n    minWidth: 140,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.5,\n    shadowRadius: 8,\n    elevation: 10,\n    zIndex: 1001,\n  },\n  menuItem: {\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#3a3a3a',\n  },\n  menuItemText: {\n    color: '#ffffff',\n    fontSize: 14,\n    fontWeight: '500',\n  },\n  itemCount: {\n    color: '#888',\n    fontSize: 14,\n    fontWeight: '600',\n    marginLeft: 'auto',\n  },\n  scrollView: {\n    flex: 1,\n  },\n  inventoryGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    padding: 8,\n  },\n  itemCard: {\n    width: '18%',\n    aspectRatio: 1,\n    margin: '1%',\n    borderRadius: 8,\n    borderWidth: 3,\n    overflow: 'hidden',\n  },\n  itemImageContainer: {\n    width: '100%',\n    height: '100%',\n    padding: 4,\n  },\n  itemImage: {\n    width: '100%',\n    height: '100%',\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 32,\n  },\n  emptyIcon: {\n    fontSize: 64,\n    marginBottom: 16,\n  },\n  emptyText: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    textAlign: 'center',\n  },\n  modalOverlay: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(0,0,0,0.7)',\n  },\n  modalContent: {\n    backgroundColor: '#2a2a2a',\n    borderRadius: 12,\n    padding: 20,\n    alignItems: 'center',\n    width: '80%',\n    maxWidth: 400,\n  },\n  modalImage: {\n    width: '100%',\n    height: 200,\n    marginBottom: 15,\n    borderRadius: 8,\n  },\n  modalTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#ffffff',\n    marginBottom: 8,\n  },\n  modalMeta: {\n    fontSize: 16,\n    color: '#888',\n    marginBottom: 5,\n  },\n  multiplierText: {\n    color: '#fbbf24',\n    fontWeight: '600',\n  },\n  modalDelete: {\n    backgroundColor: '#ef4444',\n    paddingVertical: 12,\n    paddingHorizontal: 25,\n    borderRadius: 8,\n    marginTop: 20,\n  },\n  modalClose: {\n    marginTop: 15,\n  },\n  selectedOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderRadius: 8,\n  },\n  selectedText: {\n    fontSize: 40,\n    color: '#f59e0b',\n    fontWeight: 'bold',\n  },\n  iconCircle: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginRight: 10,\n    backgroundColor: 'transparent',\n  },\n  iconEmoji: {\n    fontSize: 22,\n    marginBottom: 0,\n  },\n  filterBarSpacer: {\n    marginLeft: 'auto',\n  },\n});\n\nexport default InventoryScene;","size_bytes":17842}},"version":2}